{"/exception/advanced":{"title":"Advanced","data":{"advanced#Advanced":"","non-official-status-codes#Non-official status codes":"While their usage is not recommended, some status codes might be found in the wild (generally server status codes).\nimport { createHttpException, HttpServerException } from '@httpx/exception';\nconst nonOfficialStatusCodes = [\n  [509, 'Might refer to bandwidth limit'],\n  [525, 'Might refer to SSL Handshake Failed (ie: cloudflare)'],\n  [526, 'Might refer to Invalid SSL Certificate (ie: cloudflare)'],\n  ['...', '...'],\n];\nconst e = createHttpException(509, {\n  // optional HttpExceptionParams\n}); // `e2 instanceof HttpServerException\n// alternatively\nconst alternate = new HttpServerException({\n  statusCode: 509,\n  // ...(optional HttpExceptionParams)\n});"}},"/exception/ecosystem":{"title":"Ecosystem","data":{"recipes#Recipes":"","validation-issues#Validation issues":"Although field validation issues aren't part of the specs, they are often used by frameworks or apis in\ncombination with the 422 status code (HttpUnprocessableEntity). For convenience, it's possible to directly\nattach them to the exception. That allows to easily access them in an error handler\n(ie: json-api errors...). Be aware that for simple request validation\nthe 400 status code is more appropriate (one message).\nimport { HttpUnprocessableEntity } from '@httpx/exception';\nconst e422 = new HttpUnprocessableEntity({\n  issues: [\n    {\n      message: 'Invalid email',\n      path: 'email',\n      code: 'invalid_email',\n    },\n    {\n      message: 'Invalid address',\n      path: ['addresses', 0, 'line1'],\n      code: 'empty_string',\n    },\n  ],\n});\nconsole.log(e422.issues);\nFor reference, see github api, rails or\napi-plaform.","non-official-status-codes#Non-official status codes":"While their usage is not recommended, some status codes might be found in the wild (generally server status codes).\nimport { createHttpException, HttpServerException } from '@httpx/exception';\nconst nonOfficialStatusCodes = [\n  [509, 'Might refer to bandwidth limit'],\n  [525, 'Might refer to SSL Handshake Failed (ie: cloudflare)'],\n  [526, 'Might refer to Invalid SSL Certificate (ie: cloudflare)'],\n  ['...', '...'],\n];\nconst e = createHttpException(509, {\n  // optional HttpExceptionParams\n}); // `e2 instanceof HttpServerException\n// alternatively\nconst alternate = new HttpServerException({\n  statusCode: 509,\n  // ...(optional HttpExceptionParams)\n});"}},"/exception":{"title":"Index","data":{"":"HTTP status errors with default message, instanceof, stack and nested error cause support.\nLightweight, typical usage between 400b and 750b.\nIncludes convenience typeguards, optional contextual info and a built-in serializer\nto cover cross-environments challenges (RSC, SSR...).","quick-start#Quick start":"yarn add @httpx/exception\npnpm add @httpx/exception\nnpm install @httpx/exception","features#Features":"👉  Usage by explicit named imports and/or status code.\n🖖  Fallback to default http error message (consistency, less typing...).\n🚀  Supports commonly used contextual info (consistency, sst, logs...).\n🦄  Built-in serializer to allow cross-env uses (ssr, rsc, superjson, logs...).\n🌐  Extends native Error class with stack and cause support.\n🙏  Typescript - IDE friendly - description and links to mdn.\n♻️  Framework agnostic, no deps, runs everywhere.","usage#Usage":"","by-named-imports#By named imports":"Explicit named imports are prefixed by Http to ease\nIDE experience. Message is optional and default to the default message. Additional\nparameters are supported.\nimport { HttpNotFound, HttpBadRequest, HttpClientException } from '@httpx/exception';\nconst e = new HttpNotFound();\n// 👉 e.message     -> 'Not found' (default message)\n// 👉 e.statusCode  -> 404\n// 👉 -> e instanceof HttpClientException\nconst e400 = new HttpBadRequest('Problems parsing JSON');\n// 👉 e.message     -> 'Problems parsing JSON'\n// ...","by-status-code#By status code":"The createHttpException function allows to create an exception from an\narbitrary status code.\nimport { createHttpException } from '@httpx/exception';\nconst e404 = createHttpException(404); // e404 instanceof HttpClientException\nconst e500 = createHttpException(500); // e500 instanceof HttpServerException\nAdditional parameters can be provided as a second argument.\nimport { createHttpException, HttpNotImplemented } from \"@httpx/exception\";\nthrow createHttpException(404, 'The graal is yet to find !');\nconst e500 = createHttpException(500, {\n  message: 'Something really wrong happened.',\n  url: 'https://api.dev/gateway',\n  cause: new HttpNotImplemented(), // or any Error...\n});","parameters#Parameters":"Http exceptions and createHttpException accept a parameter of type string | HttpExceptionParams. If no parameter\nis provided the default message is used.","error-context#Error context":"It's possible to attach informational context to an exception. This is particularly useful when used with\ncentralized logging / error reporting.\nHttpExceptionParams\tType\tDescription\tmessage\tstring\tError.message, see about default message.\turl\tstring\tOrigin url (about context).\tmethod\tHttpMethod\tOrigin http method (about context).\tcode\tstring\tCustom code (about context).\terrorId\tstring\tUnique id (about context).\tcause\tError\tError.cause, see also about error cause.\tissues\tValidationIssues[]\tOnly supported by HttpUnprocessableEntity (422)\t\nExample:\nimport { HttpGatewayTimeout, HttpInternalServerError } from '@httpx/exception';\nconst e500 = new HttpInternalServerError({\n     url: 'https://api.dev/gateway',\n     method: 'GET',\n     code: 'ERR_UNREACHABLE_SERVICE',\n     errorId: nanoid(),\n     // 👉 nesting\n     cause: new HttpGatewayTimeout({\n        message: 'This Serverless Function has timed out',\n        errorId: 'cdg1::h99k2-1664884491087-b41a2832f559',\n     }),\n});","properties#Properties":"All parameters are exposed as properties.\nHttpException\tType\tDescription\tstatusCode\tnumber\tHttp error status code (400-599).\tmessage\tstring\tDefault or provided message.\turl?\tstring | undefined\tOrigin url (about context).\tmethod?\tHttpMethod | undefined\tOrigin http method (about context).\tcode?\tstring | undefined\tCustom code (about context).\terrorId?\tstring | undefined\tUnique id (about context).\tstack?\tstring | undefined\t@see Error.prototype.stack on MDN.\tcause?\tError | undefined\t@see about error cause\tissues?\tValidationIssues[] | undefined\tOnly supported by HttpUnprocessableEntity (422)\t\nimport { HttpUnprocessableEntity } from '@httpx/exception';\nconst e422 = new HttpUnprocessableEntity({\n   message: 'Request validation failed',\n   url: 'https://acme.org/api/user/create',\n   method: 'POST',\n   issues: [   // typed as ValidationIssues[]\n        {\n            message: 'Invalid address',\n            path: ['addresses', 0, 'line1'],\n            code: 'empty_string',\n        },\n  ]\n});\n// 👉 e422.issues\n// 👉 e422.method === 'POST'\n// ...","static-members#Static members":"All exceptions have a static STATUS, this can improve readability in some cases.\nimport {createHttpException, HttpMethodNotAllowed } from '@httpx/exception';\nconst { statusCode } = createHttpException(405);\nswitch (statusCode) {\n    case HttpMethodNotAllowed.STATUS:\n       console.log(statusCode); // 👉 405\n       break;\n}","generic-exception#Generic exception":"import { HttpClientException, HttpServerException } from \"@httpx/exception\";\nconst e404 = new HttpClientException(404, 'optional message or params');\nconst e500 = new HttpServerException(500, 'optional message or params');"}},"/exception/recipes":{"title":"Recipes","data":{"recipes#Recipes":"","validation-issues#Validation issues":"Although field validation issues aren't part of the specs, they are often used by frameworks or apis in\ncombination with the 422 status code (HttpUnprocessableEntity). For convenience, it's possible to directly\nattach them to the exception. That allows to easily access them in an error handler\n(ie: json-api errors...). Be aware that for simple request validation\nthe 400 status code is more appropriate (one message).\nimport { HttpUnprocessableEntity } from '@httpx/exception';\nconst e422 = new HttpUnprocessableEntity({\n  issues: [\n    {\n      message: 'Invalid email',\n      path: 'email',\n      code: 'invalid_email',\n    },\n    {\n      message: 'Invalid address',\n      path: ['addresses', 0, 'line1'],\n      code: 'empty_string',\n    },\n  ],\n});\nconsole.log(e422.issues);\nFor reference, see github api, rails or\napi-plaform."}},"/exception/usage":{"title":"Usage","data":{}},"/":{"title":"Index","data":{"":"Project\nDescription"}},"/license":{"title":"License","data":{"license#License":"MIT LicenseCopyright (c) 2022-current Sébastien Vanvelthem and contributors.Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."}},"/sponsors":{"title":"Sponsors","data":{"sponsors-️#Sponsors ❤️":"If you are enjoying some of my OSS guides or libs for your company, I'd really appreciate a sponsorship, a coffee or a dropped star. That gives me a tasty morning boost and help me to make some of my ideas come true 🙏"}},"/dsn-parser":{"title":"Dsn Parser","data":{"":"DSN & JDBC string parser with query params support in a light and modern package.","features#Features":"👉  Parse individual fields (ie: driver, user, password, host...)\n🖖  Handle query string parameters and converts to boolean and numeric values.\n🦄  Handle special characters like /, :... in the password (some libs won't).\n🚀  Error with indicative message / reasons (discriminated union or throwable).\n🛡️  Don't leak passwords in the error message.\n🙏  Assertion and typeguard helpers\n🤗  Ecosystem friendly (ie: zod integration).","install#Install":"yarn add @httpx/dsn-parser\npnpm add @httpx/dsn-parser\nnpm install @httpx/dsn-parser","usage#Usage":"","parsedsnorthrow#parseDsnOrThrow":"Usage with exceptions\nimport { parseDsnOrThrow } from \"@httpx/dsn-parser\";\nconst dsn = \"redis://user:p@/ssword@localhost:6379/0?ssl=true\";\ntry {\n  const parsedDsn = parseDsnOrThrow(dsn);\n  assert.deepEqual(parsedDsn, {\n    driver: \"redis\",\n    pass: \"p@/ssword\",\n    host: \"localhost\",\n    user: \"user\",\n    port: 6379,\n    db: \"0\",\n    params: {\n      ssl: true,\n    },\n  });\n} catch (e) {\n  // example:\n  // e -> Error(\"Can't parse dsn: Invalid port: 12345678 (INVALID_PORT)\")\n}","parsedsn#parseDsn":"Usage with discriminated union.\nimport { parseDsn } from \"@httpx/dsn-parser\";\nconst dsn = \"redis://user:p@/ssword@localhost:6379/0?ssl=true\";\nconst parsed = parseDsn(dsn);\nif (parsed.success) {\n  assert.deepEqual(parsed.value, {\n    driver: \"redis\",\n    pass: \"p@/ssword\",\n    host: \"localhost\",\n    user: \"user\",\n    port: 6379,\n    db: \"0\",\n    params: {\n      ssl: true,\n    },\n  });\n} else {\n  assert.deepEqual(parsed, {\n    success: false,\n    // Reasons might vary\n    reason: \"INVALID_PORT\",\n    message: \"Invalid http port: 12345678\",\n  });\n}","options#Options":"import { parseDsn, type ParseDsnOptions } from \"@httpx/dsn-parser\";\nconst dsn = \"mySql://localhost:6379/db\";\nconst parsed = parseDsn(dsn, {\n  lowercaseDriver: true,\n  // Overrides, allows to force some values (ParseDsnOptions)\n  overrides: {\n    db: \"db3\",\n    port: undefined,\n  },\n});\nassert.deepEqual(parsed.value, {\n  driver: \"mysql\",\n  host: \"localhost\",\n  db: \"db3\",\n});\nParams\tType\tDescription\tlowercaseDriver\tboolean\tDriver name in lowercase, default false\toverrides\tParseDsnOptions\tOverrides allows to force specific values","utilities#Utilities":"","typeguard#Typeguard":"import { isParsableDsn, type ParsableDsn } from \"@httpx/dsn-parser\";\nconst dsn = \"postgresql://localhost:6379/db\";\nif (isParsableDsn(dsn)) {\n  // known to be ParsableDSN\n}","assertion#Assertion":"import { assertParsableDsn, ParsableDsn } from \"@httpx/dsn-parser\";\ntry {\n  assertParsableDsn(\"redis:/\");\n  // Type is narrowed to string (ParsableDsn) if it\n  // didn't throw.\n} catch (e) {\n  assert.equal(e.message, \"Cannot parse DSN (PARSE_ERROR)\");\n}","convertjdbctodsn#convertJdbcToDsn":"Utility to convert jdbc dsn.\nUseful for prisma using sqlserver.\nimport { convertJdbcToDsn } from \"@httpx/dsn-parser\";\nconst jdbcDsn =\n  \"sqlserver://localhost:1433;database=my-db;authentication=default;user=sa;password=pass03$;encrypt=true;trustServerCertificate=true\";\nconst dsn = convertJdbcToDsn(jdbc);\n// -> 'sqlserver://localhost:1433?database=my-db&authentication=default&user=sa&password=pass03$&encrypt=true&trustServerCertificate=true'","dsn-parsing#DSN parsing":"","requirements#Requirements":"The minimum requirement for dsn parsing is to have a host and\na driver (/[a-z0-9]+/i) defined. All other options are optional.\nexport type ParsedDsn = {\n  driver: string;\n  host: string;\n  user?: string;\n  pass?: string;\n  port?: number;\n  db?: string;\n  /** Query params */\n  params?: Record<string, number | string | boolean>;\n};","dsn-support#DSN support":"Things like:\nconst validExamples = [\n  \"postgresql://postgres:@localhost:5432/prisma-db\",\n  \"redis://us_er-name:P@ass-_:?/ssw/rd@www.example.com:6379/0?cache=true\",\n  //...\n];\nshould work.","query-parameters#Query parameters":"Simple query parameters are supported (no arrays, no nested). For convenience\nit will cast 'true' and 'false' to booleans,\nparse numeric string to numbers if possible. When a query\nparameter does not contain a value, it will be returned as true.\nconst dsn = \"redis://host?index=1&compress=false&ssl\";\nconst parsed = parseDsn(dsn);\nassert.deepEqual(parsed.value.params, {\n  index: 1,\n  compress: false,\n  ssl: true,\n});","portability#Portability":"parseDsn won't make any assumptions on default values (i.e: default port for mysql...).","validation#Validation":"parseDsn wraps its result in a discriminated union\nto allow the retrieval of validation errors. No try... catchneeded and full typescript support.Reason codes are guaranteed in semantic versions and messages does not\nleak credentials\nconst parsed = parseDsn(\"redis://localhost:65636\");\nassert.deepEqual(parsed, {\n  success: false,\n  reason: \"INVALID_PORT\",\n  message: \"Invalid port: 65636\",\n});\nif (!parsed.success) {\n  // `success: false` narrows the type to\n  // {\n  //   reason: 'PARSE_ERROR'|'INVALID_ARGUMENT'|...\n  //   message: string\n  // }\n  log(parsed.reason);\n}\nReason\tMessage\tComment\t'PARSE_ERROR'\tCannot parse DSN\tRegexp failed\t'INVALID_ARGUMENT'\tDSN must be a string\t\t'EMPTY_DSN'\tDSN cannot be empty\t\t'INVALID_PORT'\tInvalid port: ${port}\t[1-65535]","ecosystem#Ecosystem":"","zod-integration-example#Zod integration example":"The isParsableDsn can be easily plugged into zod custom validation. Example:\nimport { z } from \"zod\";\nimport { isParsableDsn, type ParsableDsn } from \"@httpx/dsn-parser\";\nexport const serverEnvSchema = z.object({\n  PRISMA_DATABASE_URL: z.custom<ParsableDsn>(\n    (dsn) => isParsableDsn(dsn),\n    \"Invalid DSN format.\"\n  ),\n});\nserverEnvSchema.parse(process.env);","faq#Faq":"","why--in-password-matters#Why '/' in password matters":"Some libs (ioredis...) still might fail parsing a password containing '/',\nunfortunately they're pretty convenient, i.e:\nopenssl rand 60 | openssl base64 -A\n# YFUXIG9INIK7dFyE9aXtxLmjmnYL0zv6YluBJJbC6alKIBema/MwEGy3VUpx0oLAvWHUFGFMagAdLxrB"}},"/exception/bundle":{"title":"Bundle","data":{"about-bundle#About bundle":"","compatibility#Compatibility":"Node 18+ and es2022 compatibility is ensured on the CI.Browser builds follows the .browserslistrc\nconfiguration. From the browserslist defaults:\nChrome 96+, Firefox 90+, Edge 91+, Safari 15+ and Opera 77+\nare set as minimal supported versions.For older browsers:\nMost frontend frameworks can transpile the library (ie: nextjs...)\nYou might want to add the error-cause-polyfill to support\nnested errors (if not present they are simply discarded - no runtime errors).","size#Size":"Code and bundler have been tuned to target a minimal compressed footprint\nfor the browser. In typical usage the bundle size will vary between 450b to 750b compressed\n(including default messages for the 43 status codes).ESM individual imports are tracked by a\nsize-limit configuration.\nScenario\tSize (compressed)\tImport generic exception (HttpClientException)\t~ 370b\tImport 1 client exception\t~ 400b\tImport 2 client exceptions\t~ 415b\tImport 6 client exceptions\t~ 430b\tImport 1 client + 1 server exceptions\t~ 415b\tImport createHttpException (all 43 exceptions)\t~ 690b\tImport fromJson (incl createHttpException)\t~ 1100b\tAll exceptions + typeguards + serializer\t~ 1500b\t\nFor CJS usage (not recommended) track the size on bundlephobia.","packaging#Packaging":"This library offers a dual cjs/esm bundle. The (optional) serializer code has been tuned to\navoid issues with dual package hazards.The export fields and the builds are checked on the CI with are-the-types-wrong.\nPS: Plans to remove cjs support might land in a next major version.","typescript#Typescript":"This library targets typescript 5+ with descriptions (see\nthe generated api docs)."}}}