{"/exception/advanced":{"title":"Advanced","data":{"advanced#Advanced":"","validation-errors#Validation errors":"Although field validation errors aren't part of the specs, they are often used by frameworks or apis in\ncombination with the 422 status code (HttpUnprocessableEntity). For convenience, it's possible to directly\nattach them to the exception. That allows to easily access them in an error handler\n(ie: json-api errors...). Be aware that for simple request validation\nthe 400 status code is more appropriate (one message).\nimport { HttpUnprocessableEntity } from '@httpx/exception';\nconst e422 = new HttpUnprocessableEntity({\n  errors: [\n    {\n      message: 'Invalid email',\n      path: 'email',\n      code: 'invalid_email',\n    },\n    {\n      message: 'Invalid address',\n      path: ['addresses', 0, 'line1'],\n      code: 'empty_string',\n    },\n  ],\n});\nconsole.log(e422.errors);\nFor reference, see github api, rails or\napi-plaform.","non-official-status-codes#Non-official status codes":"While their usage is not recommended, some status codes might be found in the wild (generally server status codes).\nimport { createHttpException, HttpServerException } from '@httpx/exception';\nconst nonOfficialStatusCodes = [\n  [509, 'Might refer to bandwidth limit'],\n  [525, 'Might refer to SSL Handshake Failed (ie: cloudflare)'],\n  [526, 'Might refer to Invalid SSL Certificate (ie: cloudflare)'],\n  ['...', '...'],\n];\nconst e = createHttpException(509, {\n  // optional HttpExceptionParams\n}); // `e2 instanceof HttpServerException\n// alternatively\nconst alternate = new HttpServerException({\n  statusCode: 509,\n  // ...(optional HttpExceptionParams)\n});"}},"/exception":{"title":"Index","data":{"":"HTTP error responses with default message, instanceof, stack and error cause support.\nLightweight, esm starts at 350b. Includes convenience typeguards, optional\ncontextual info and a built-in serializer to cover cross-environments challenges (RSC, SSR...).","features#Features":"ðŸ‘‰Â  Usage by named imports or status code.\nðŸ––Â  Fallback to default http error message (consistency, less typing...).\nðŸš€Â  Supports commonly used contextual info (consistency, sst, logs...).\nðŸ¦„Â  Built-in serializer to allow cross-env uses (ssr, rsc, superjson, logs...).\nðŸŒÂ  Extends native Error class with stack and cause support.\nðŸ™Â  Typescript - IDE friendly - description and links to mdn.\nâ™»ï¸Â  Framework agnostic, no deps, runs everywhere.","install#Install":"yarn add @httpx/exception\npnpm add @httpx/exception\nnpm install @httpx/exception"}},"/exception/parameters":{"title":"Parameters","data":{"httpexception-parameters#HttpException parameters":"Http exception optionally accepts a parameter of type string | HttpExceptionParams. If no parameter\nis provided a default message will be set.\nWhen a string is provided it will be used as the error message, otherwise you can use the following params:\nHttpExceptionParams\tType\tDescription\tmessage\tstring?\tError.message, see about default message.\turl\tstring?\tOrigin url (about context).\tmethod\tstring?\tOrigin http method (about context).\tcode\tstring?\tCustom code (about context).\terrorId\tstring?\tUnique id (about context).\tcause\tError?\tError.cause, see also about error cause.\t\nExample:","httpexception-properties#HttpException properties":"HttpException\tType\tDescription\tstatusCode\tnumber\tHttp error status code (400-599).\tmessage\tstring\tDefault or provided message.\turl\tstring?\tOrigin url (about context).\tmethod\tstring?\tOrigin http method (about context).\tcode\tstring?\tCustom code (about context).\terrorId\tstring?\tUnique id (about context).\tstack\tstring?\t@see Error.prototype.stack on MDN.\tcause\tError?\t@see about error cause\terrors?\tValidationError[]\tOnly supported by HttpUnprocessableEntity (422)"}},"/exception/usage":{"title":"Usage","data":{"install#Install":"yarn add @httpx/exception\npnpm add @httpx/exception\nnpm install @httpx/exception\nYou might want to install a polyfill for Error.cause\nif you need to support older browsers.\n(error-cause-polyfill). This is not needed on node >=16.9.0.","usage#Usage":"","by-named-imports#By named imports":"Explicit named imports are prefixed by Http to ease\nIDE experience. Message is optional and default to the default message. Additional\nparameters are supported such as url, method, code, errorId and cause.\nimport { HttpNotFound, HttpBadRequest } from '@httpx/exception';\nconst e1 = new HttpNotFound();\ne1.message;    // 'Not found'\ne2.statusCode; // 404\nconst e2 = new HttpNotFound('Page not found');\ne2.message;    // 'Page not found'\ne2.statusCode; // 404\nconst e400 = new HttpBadRequest('Problems parsing JSON');\nimport { HttpGatewayTimeout, HttpInternalServerError } from '@httpx/exception';\nconst e500 = new HttpInternalServerError({\n     url: 'https://api.dev/gateway',\n     method: 'GET',\n     code: 'ERR_UNREACHABLE_SERVICE',\n     errorId: nanoid(),\n     cause: new HttpGatewayTimeout({\n        message: 'This Serverless Function has timed out',\n        errorId: 'cdg1::h99k2-1664884491087-b41a2832f559',\n     }),\n});\ne500.message;     // 'Internal server error'\ne500.statusCode;  // 500\ne500.url;         // 'https://api.dev/gateway'\ne500.method;      // 'GET'\n// ...\nimport { HttpUnprocessableEntity } from '@httpx/exception';\nconst e422 = new HttpUnprocessableEntity({\n   message: 'Request validation failed',\n   issues: [   // typed as ValidationIssues[]\n        {\n            message: 'Invalid email',\n            path: 'email',\n            code: 'invalid_email',\n        },\n        {\n            message: 'Invalid address',\n            path: ['addresses', 0, 'line1'],\n            code: 'empty_string',\n        },\n  ]\n});\nAccording to MDN, the 422-HttpUnprocessableEntity status code is reserved for WebDAV, but it is widely used in REST APIs\n(ie: github, rails...).The choice to add validation errors to the 422 exception might be controversial and is optional. However, it offers\nsome benefits as a global error handler can leverage them to generate error responses\n(ie: json-api error responses).","by-status-code#By status code":"The createHttpException function allows to create an exception from an\narbitrary status code.\nimport { createHttpException } from '@httpx/exception';\nconst e404 = createHttpException(404); // e404 instanceof HttpClientException\nconst e500 = createHttpException(500); // e500 instanceof HttpServerException\nAdditional parameters can be provided as a second argument.\nthrow createHttpException(404, 'The graal is yet to find !');\nthrow createHttpException(500, {\n  message: 'Something really wrong happened.',\n  url: 'https://api.dev/gateway',\n  cause: new HttpNotImplemented(), // or any Error...\n});\nNo checks are done about the validity of the provided status code. See also\nabout non-official status codes\nimport { HttpNotFound } from '@httpx/exception';\n// Simple\nthrow new HttpNotFound(); // message = 'Not found'\n// Custom message\nthrow new HttpNotFound('User not found');\nimport {\n  HttpException,\n  HttpGatewayTimeout,\n  HttpInternalServerError,\n} from '@httpx/exception';\n// Another way (could be with ts-result, either...)\nconst fetchData = async <T,>(url: string): Promise<T | HttpException> => {\n  return new HttpInternalServerError({\n    url,\n    cause: new HttpGatewayTimeout({\n      code: 'This Serverless Function has timed out',\n      errorId: 'cdg1::h99k2-1664884491087-b41a2832f559',\n    }),\n  });\n};\nconst data = await fetchData<{ data: unknown }>('https://api.dev/gateway');\nif (data instanceof Error) {\n  // handle error\n} else {\n}","parameters#Parameters":"Http exception optionally accepts a parameter of type string | HttpExceptionParams. If no parameter\nis provided a default message will be set.\nWhen a string is provided it will be used as the error message, otherwise you can use the following params:\nHttpExceptionParams\tType\tDescription\tmessage\tstring?\tError.message, see about default message.\turl\tstring?\tOrigin url (about context).\tmethod\tstring?\tOrigin http method (about context).\tcode\tstring?\tCustom code (about context).\terrorId\tstring?\tUnique id (about context).\tcause\tError?\tError.cause, see also about error cause.\t\nExample:","properties#Properties":"HttpException\tType\tDescription\tstatusCode\tnumber\tHttp error status code (400-599).\tmessage\tstring\tDefault or provided message.\turl\tstring?\tOrigin url (about context).\tmethod\tstring?\tOrigin http method (about context).\tcode\tstring?\tCustom code (about context).\terrorId\tstring?\tUnique id (about context).\tstack\tstring?\t@see Error.prototype.stack on MDN.\tcause\tError?\t@see about error cause\tissues?\tValidationIssues[]\tOnly supported by HttpUnprocessableEntity (422)"}},"/":{"title":"Index","data":{"":"Plain http exceptions for node, deno, edge and browsers. No deps, lightweight, first class typescript\nexperience. Offer a built-in serializer in case you'll need it in hybrid context (Ã lÃ  nextjs) or for logging\npurposes."}},"/sponsors":{"title":"Sponsors","data":{"sponsors-ï¸#Sponsors â¤ï¸":"If you are enjoying some of my OSS guides or libs for your company, I'd really appreciate a sponsorship, a coffee or a dropped star. That gives me a tasty morning boost and help me to make some of my ideas come true ðŸ™"}},"/license":{"title":"License","data":{"license#License":"MIT LicenseCopyright (c) 2022-current SÃ©bastien Vanvelthem and contributors.Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."}},"/dsn-parser":{"title":"Dsn Parser","data":{"":"DSN & JDBC string parser with query params support in a light and modern package.","features#Features":"ðŸ‘‰Â  Parse individual fields (ie: driver, user, password, host...)\nðŸ––Â  Handle query string parameters and converts to boolean and numeric values.\nðŸ¦„Â  Handle special characters like /, :... in the password (some libs won't).\nðŸš€Â  Error with indicative message / reasons (discriminated union or throwable).\nðŸ›¡ï¸Â  Don't leak passwords in the error message.\nðŸ™Â  Assertion and typeguard helpers\nðŸ¤—Â  Ecosystem friendly (ie: easy integrate with zod).","install#Install":"yarn add @httpx/dsn-parser\npnpm add @httpx/dsn-parser\nnpm install @httpx/dsn-parser","usage#Usage":"","parsedsnorthrow#parseDsnOrThrow":"Usage with exceptions\nimport { parseDsnOrThrow } from \"@httpx/dsn-parser\";\nconst dsn = \"redis://user:p@/ssword@localhost:6379/0?ssl=true\";\ntry {\n  const parsedDsn = parseDsnOrThrow(dsn);\n  assert.deepEqual(parsedDsn, {\n    driver: \"redis\",\n    pass: \"p@/ssword\",\n    host: \"localhost\",\n    user: \"user\",\n    port: 6379,\n    db: \"0\",\n    params: {\n      ssl: true,\n    },\n  });\n} catch (e) {\n  // example:\n  // e -> Error(\"Can't parse dsn: Invalid port: 12345678 (INVALID_PORT)\")\n}","parsedsn#parseDsn":"Usage with discriminated union.\nimport { parseDsn } from \"@httpx/dsn-parser\";\nconst dsn = \"redis://user:p@/ssword@localhost:6379/0?ssl=true\";\nconst parsed = parseDsn(dsn);\nif (parsed.success) {\n  assert.deepEqual(parsed.value, {\n    driver: \"redis\",\n    pass: \"p@/ssword\",\n    host: \"localhost\",\n    user: \"user\",\n    port: 6379,\n    db: \"0\",\n    params: {\n      ssl: true,\n    },\n  });\n} else {\n  assert.deepEqual(parsed, {\n    success: false,\n    // Reasons might vary\n    reason: \"INVALID_PORT\",\n    message: \"Invalid http port: 12345678\",\n  });\n}","parameters#Parameters":"const dsn = \"mySql://localhost:6379/db\";\nconst parsed = parseDsn(dsn, {\n  lowercaseDriver: true,\n  overrides: {\n    db: \"db3\",\n    port: undefined,\n  },\n});\nassert.deepEqual(parsed.value, {\n  driver: \"mysql\",\n  host: \"localhost\",\n  db: \"db3\",\n});\nParams\tType\tDescription\tlowercaseDriver\t<boolean>\tDriver name in lowercase, default false\toverrides\tDSN must be a string","utilities#Utilities":"","typeguard#Typeguard":"import { isParsableDsn, type ParsableDsn } from \"@httpx/dsn-parser\";\nconst dsn = \"postgresql://localhost:6379/db\";\nif (isParsableDsn(dsn)) {\n  // known to be ParsableDSN\n}","assertion#Assertion":"import { assertParsableDsn, ParsableDsn } from \"@httpx/dsn-parser\";\ntry {\n  assertParsableDsn(\"redis:/\");\n  // Type is narrowed to string (ParsableDsn) if it\n  // didn't throw.\n} catch (e) {\n  assert.equal(e.message, \"Cannot parse DSN (PARSE_ERROR)\");\n}","convertjdbctodsn#convertJdbcToDsn":"Utility to convert jdbc dsn.\nUseful for prisma using sqlserver.\nimport { convertJdbcToDsn } from \"@httpx/dsn-parser\";\nconst jdbcDsn =\n  \"sqlserver://localhost:1433;database=my-db;authentication=default;user=sa;password=pass03$;encrypt=true;trustServerCertificate=true\";\nconst dsn = convertJdbcToDsn(jdbc);\n// -> 'sqlserver://localhost:1433?database=my-db&authentication=default&user=sa&password=pass03$&encrypt=true&trustServerCertificate=true'","dsn-parsing#DSN parsing":"","requirements#Requirements":"The minimum requirement for dsn parsing is to have a host and\na driver (/[a-z0-9]+/i) defined. All other options are optional.\nexport type ParsedDsn = {\n  driver: string;\n  host: string;\n  user?: string;\n  pass?: string;\n  port?: number;\n  db?: string;\n  /** Query params */\n  params?: Record<string, number | string | boolean>;\n};","dsn-support#DSN support":"Things like:\nconst validExamples = [\n  \"postgresql://postgres:@localhost:5432/prisma-db\",\n  \"redis://us_er-name:P@ass-_:?/ssw/rd@www.example.com:6379/0?cache=true\",\n  //...\n];\nshould work.","query-parameters#Query parameters":"Simple query parameters are supported (no arrays, no nested). For convenience\nit will cast 'true' and 'false' to booleans,\nparse numeric string to numbers if possible. When a query\nparameter does not contain a value, it will be returned as true.\nconst dsn = \"redis://host?index=1&compress=false&ssl\";\nconst parsed = parseDsn(dsn);\nassert.deepEqual(parsed.value.params, {\n  index: 1,\n  compress: false,\n  ssl: true,\n});","portability#Portability":"parseDsn won't make any assumptions on default values (i.e: default port for mysql...).","validation#Validation":"parseDsn wraps its result in a discriminated union\nto allow the retrieval of validation errors. No try... catchneeded and full typescript support.Reason codes are guaranteed in semantic versions and messages does not\nleak credentials\nconst parsed = parseDsn(\"redis://localhost:65636\");\nassert.deepEqual(parsed, {\n  success: false,\n  reason: \"INVALID_PORT\",\n  message: \"Invalid port: 65636\",\n});\nif (!parsed.success) {\n  // `success: false` narrows the type to\n  // {\n  //   reason: 'PARSE_ERROR'|'INVALID_ARGUMENT'|...\n  //   message: string\n  // }\n  log(parsed.reason);\n}\nReason\tMessage\tComment\t'PARSE_ERROR'\tCannot parse DSN\tRegexp failed\t'INVALID_ARGUMENT'\tDSN must be a string\t\t'EMPTY_DSN'\tDSN cannot be empty\t\t'INVALID_PORT'\tInvalid port: ${port}\t[1-65535]","ecosystem#Ecosystem":"","zod-integration-example#Zod integration example":"The isParsableDsn can be easily plugged into zod custom validation. Example:\nimport { z } from \"zod\";\nimport { isParsableDsn, type ParsableDsn } from \"@httpx/dsn-parser\";\nexport const serverEnvSchema = z.object({\n  PRISMA_DATABASE_URL: z.custom<ParsableDsn>(\n    (dsn) => isParsableDsn(dsn),\n    \"Invalid DSN format.\"\n  ),\n});\nserverEnvSchema.parse(process.env);","faq#Faq":"","why--in-password-matters#Why '/' in password matters":"Some libs (ioredis...) still might fail parsing a password containing '/',\nunfortunately they're pretty convenient, i.e:\nopenssl rand 60 | openssl base64 -A\n# YFUXIG9INIK7dFyE9aXtxLmjmnYL0zv6YluBJJbC6alKIBema/MwEGy3VUpx0oLAvWHUFGFMagAdLxrB"}}}