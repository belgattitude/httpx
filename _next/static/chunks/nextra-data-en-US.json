{"/exception/advanced":{"title":"Advanced","data":{"advanced#Advanced":"","generic-exception#Generic exception":"Although not recommended it's possible to create exception from base classes.\nimport { HttpClientException, HttpServerException } from \"@httpx/exception\";\nconst e404 = new HttpClientException(404, 'optional message or params');\nconst e500 = new HttpServerException(500, 'optional message or params');"}},"/exception/ecosystem":{"title":"Ecosystem","data":{"ecosystem#Ecosystem":"","serialization#Serialization":"","tupleson#Tupleson":"Example with tupleson experimental serializer.\nimport { createTson, type TsonType } from \"tupleson\";\nimport { createHttpException, HttpException, HttpUnprocessableEntity } from \"@httpx/exception\";\nimport { fromJson, toJson, type SerializerError } from \"@httpx/exception/serializer\";\nconst exceptionSerializer: TsonType<HttpException | SerializerError, string> = {\n  deserialize: (v) => fromJson(v),\n  key: \"HttpException\",\n  serialize: (v) => toJson(v),\n  test: (v) => v instanceof HttpException,\n};\nconst tson = createTson({\n  types: [exceptionSerializer],\n});\nconst obj = {\n  e422: new HttpUnprocessableEntity({\n    issues: [\n      {\n        message: \"Invalid address\",\n        path: [\"addresses\", 0, \"line1\"],\n        code: \"empty_string\",\n      },\n    ],\n  }),\n  e404: createHttpException(404),\n};\nconst serialized = tson.serialize(obj);\nconst deserialized = tson.deserialize(serialized);\nexpect(deserialized).toStrictEqual(obj);"}},"/exception/recipes":{"title":"Recipes","data":{"recipes#Recipes":"","validation-issues#Validation issues":"Although field validation issues aren't part of the specs, they are often used by frameworks or apis in\ncombination with the 422 status code (HttpUnprocessableEntity). For convenience, it's possible to directly\nattach them to the exception. That allows to easily access them in an error handler\n(ie: json-api errors...). Be aware that for simple request validation\nthe 400 status code is more appropriate (one message).\nimport { HttpUnprocessableEntity } from '@httpx/exception';\nconst e422 = new HttpUnprocessableEntity({\n  issues: [\n    {\n      message: 'Invalid email',\n      path: 'email',\n      code: 'invalid_email',\n    },\n    {\n      message: 'Invalid address',\n      path: ['addresses', 0, 'line1'],\n      code: 'empty_string',\n    },\n  ],\n});\nconsole.log(e422.issues);\nFor reference, see github api, rails or\napi-plaform."}},"/":{"title":"Index","data":{"":"Project\nDescription"}},"/license":{"title":"License","data":{"license#License":"MIT LicenseCopyright (c) 2022-current S√©bastien Vanvelthem and contributors.Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."}},"/sponsors":{"title":"Sponsors","data":{"sponsors-Ô∏è#Sponsors ‚ù§Ô∏è":"If you are enjoying some of my OSS guides or libs for your company, I'd really appreciate a sponsorship, a coffee or a dropped star. That gives me a tasty morning boost and help me to make some of my ideas come true üôè"}},"/assert":{"title":"@httpx/assert","data":{"":"Assertions and typeguards as primitives","features#Features":"üëâ¬† Typeguards and assertions with a consistent style.\nüëâ¬† Assertions with useful default error message.\nüëâ¬† Return weak opaque types for boolean, strings and numbers.\nüëâ¬† Optimized tree-shakability, starts at 56b.\nüëâ¬† Don't leak values in the default assertion error messages.\nüëâ¬† No deps. Node, browser and edge support.","install#Install":"yarn add @httpx/assert\npnpm add @httpx/assert\nnpm install @httpx/assert","documentation#Documentation":"üëâ Official website, GitHub Readme or generated api doc","introduction#Introduction":"Assertions and typeguards as primitives\nwarning: pre-v1, use at your own risks","install-1#Install":"$ npm install @httpx/assert\n$ yarn add @httpx/assert\n$ pnpm add @httpx/assert","features-1#Features":"üëâ¬† Typeguards and assertions with a consistent style.\nüëâ¬† Assertions with useful default error message.\nüëâ¬† Return weak opaque types for boolean, strings and numbers.\nüëâ¬† Optimized tree-shakability, starts at 56b.\nüëâ¬† Don't leak values in the default assertion error messages.\nüëâ¬† No deps. Node, browser and edge support.","documentation-1#Documentation":"üëâ Official website, GitHub Readme or generated api doc","introduction-1#Introduction":"","consistent-style#Consistent style":"Typeguards starts with isXXX and have an assertion counterpart named assertXXX.isParsableXXX and assertParsableXXX denotes a string.","weak-opaque-types#Weak opaque types":"For string, number and boolean the returned type is tagged with a weak opaque type.\nIt can optionally be used to enforce that the value was checked.For example:\nimport { assertUuidV7, type UuidV7 } from '@httpx/assert';\nimport { HttpUnprocessableEntity } from '@httpx/exception';\nconst persistRecord = async (uuid: UuidV7) => {\n  // uuid is compatible with string.\n  return await db.raw(`insert into tbl(uuid) values (${uuid})`)\n}\nconst v = 'xxx'; // unknown\nassertUuidV7(v, () => new HttpUnprocessableEntity());\n// üëâ v is known to be `string & WeakOpaqueContainer<'UuidV4'>`\nawait persistRecord(v); // will work\nawait persistRecord('a_string'); // won't","assertions-error-messages#Assertions error messages":"When an assertion fail, a native TypeError\nis thrown by default with a message indicating the requirement and and information about the\ntested value. As an example:\nexpect(() => assertUuid('123')).toThrow(\n  new TypeError('Value is expected to be an uuid, got: string(length:3)')\n);\nexpect(() => assertUuid(false, undefined, { version: 1 })).toThrow(\n  new TypeError('Value is expected to be an uuid v1, got: boolean(false)')\n);\nexpect(() => assertUuidV1(Number.NaN)).toThrow(\n  new TypeError('Value is expected to be an uuid v1, got: NaN')\n);\nexpect(() => assertUuidV3(new Error())).toThrow(\n  new TypeError('Value is expected to be an uuid v3, got: Error')\n);\nexpect(() => assertUuidV4(new Date())).toThrow(\n  new TypeError('Value is expected to be an uuid v4, got: Date')\n);\nexpect(() => assertUuidV5(() => {})).toThrow(\n  new TypeError('Value is expected to be an uuid v5, got: function')\n);\nexpect(() => assertUuidV7(() => {})).toThrow(\n  new TypeError('Value is expected to be an uuid v7, got: function')\n);\n//...\nAlternatively it's possible to provide either a message or function returning\nan Error. For example:\nimport { assertEan13, assertStringNonEmpty } from '@httpx/assert';\nimport { HttpBadRequest } from '@httpx/exception';\nassertEan13('123', 'Not a barcode'); // üëà Will throw a TypeError('Not a barcode')\nassertStringNonEmpty(lang, () => new HttpBadRequest('Missing language'));","usage#Usage":"","type-related#Type related":"","assertnever#assertNever":"import { assertNever } from '@httpx/assert';\ntype PromiseState = 'resolved' | 'rejected' | 'running'\nconst state: PromiseState = 'rejected';\nswitch(state) {\n  case 'resolved': return v;\n  case 'rejected': return new Error();\n  default:\n    assertNever(state); // üëà TS will complain about missing 'running' state\n    // ‚òùÔ∏è Will throw a TypeError in js.\n}\nPS: you can use the assertNeverNoThrow with the same behaviour except that it\ndoesn't throw and return the value instead (no runtime error).","object-related#Object related":"","isplainobject#isPlainObject":"Name\tType\tComment\tisPlainObject<T?>\tPlainObject\t\tassertPlainObject<T?>\tPlainObject\t\t\nimport { isPlainObject, assertPlainObject } from '@httpx/assert';\n// Simple case: without generic value\nisPlainObject({cwol: true}); // üëà true\nisPlainObject(new Promise()); // üëà false\nassertPlainObject({});\n// With generic value (unchecked at runtime!)\ntype CustomType = {\n  name: string;\n  deep: {\n    yes: boolean | null;\n  };\n};\nconst value = {\n  name: 'hello',\n  deep: {\n    yes: true,\n  },\n} as unknown;\nif (isPlainObject<CustomType>(value)) {\n  // Notice it's a deep partial to allow autocompletion\n  value?.deep?.yes; // üëà  yes will be unknown to reflect that not runtime check was done\n}","number-related#Number related":"","isnumbersafeint#isNumberSafeInt":"import { assertNumberSafeInt, isNumberSafeInt } from '@httpx/assert';\nisNumberSafeInt(10n); // üëâ false\nisNumberSafeInt(BigInt(10)); // üëâ false\nisNumberSafeInt(Number.MAX_SAFE_INTEGER); // üëâ true\nassertNumberSafeInt(Number.MAX_SAFE_INTEGER + 1); // üëâ throws","array-related#Array related":"","arraynonempty#ArrayNonEmpty":"Name\tType\tOpaque type\tComment\tisArrayNonEmpty\tunknown[]\tArrayNonEmpty\t\tassertArrayNonEmpty\tunknown[]\tArrayNonEmpty\t\t\nimport { isArrayNonEmpty, assertArrayNonEmpty, type ArrayNonEmpty } from '@httpx/assert';\nisArrayNonEmpty([]) // üëâ false\nisArrayNonEmpty([0,1]) // üëâ true\nisArrayNonEmpty([null]) // üëâ true\nassertArrayNonEmpty([]) // üëâ throws","string-related#String related":"","stringnonempty#StringNonEmpty":"Name\tType\tOpaque type\tComment\tisStringNonEmpty\tstring\tStringNonEmpty\tTrims the value\tassertStringNonEmpty\tstring\tStringNonEmpty\tTrims the value\t\nimport { assertStringNonEmpty, isStringNonEmpty, type StringNonEmpty } from '@httpx/assert';\nisStringNonEmpty(''); // üëâ false\nisStringNonEmpty(' '); // üëâ false: trim by default\nassertStringNonEmpty(''); // üëâ throws","parsablesafeint#ParsableSafeInt":"Name\tType\tOpaque type\tComment\tisParsableSafeInt\tstring\tParsableSafeInt\t\tassertParsableSafeInt\tstring\tParsableSafeInt\t\t\nimport { assertStrParsableSafeInt, isStrParsableSafeInt } from '@httpx/assert';\nisStrParsableSafeInt(2); // üëâ false\nisStrParsableSafeInt(`${Number.MAX_SAFE_INTEGER}`); // üëâ true\nassertStrParsableSafeInt(`${Number.MAX_SAFE_INTEGER}1`); // üëâ throws","isparsablestrictisodatez#isParsableStrictIsoDateZ":"Ensure a string contains a strict iso datetime with microseconds and utc suffix\n(aka: zulu time). Date is checked for validity.\nName\tType\tOpaque type\tComment\tisParsableStrictIsoDateZ\tstring\tParsableStrictIsoDateZ\t\tassertParsableStrictIsoDateZ\tstring\tParsableStrictIsoDateZ\t\t\nimport { isParsableStrictIsoDateZ, assertParsableStrictIsoDateZ, type ParsableStrictIsoDateZ } from '@httpx/assert';\nisParsableStrictIsoDateZ(new Date().toISOString()); // üëâ true\nisParsableStrictIsoDateZ('2023-12-29T23:37:31.653z'); // üëâ true\nisParsableStrictIsoDateZ('2023-02-29T23:37:31.653'); // üëâ false, cause no 29th february in 2023\nassertParsableStrictIsoDateZ('2023-02-29T23:37:31.653z'); // üëâ throws cause no 29th february","uuid#Uuid":"","isuuid#isUuid":"Name\tType\tOpaque type\tComment\tisUuid\tstring\tUuidV1 | UuidV3 | UuidV4 | UuidV5 | UuidV7\t\tisUuidV1\tstring\tUuidV1\t\tisUuidV3\tstring\tUuidV3\t\tisUuidV4\tstring\tUuidV4\t\tisUuidV5\tstring\tUuidV5\t\tassertUuid\tstring\tUuidV1 | UuidV3 | UuidV4 | UuidV5 | UuidV7\t\tassertUuidV1\tstring\tUuidV5\t\tassertUuidV3\tstring\tUuidV3\t\tassertUuidV4\tstring\tUuidV4\t\tassertUuidV5\tstring\tUuidV5\t\tassertUuidV7\tstring\tUuidV7\t\tgetUuidVersion\t1 | 3 | 4 | 5 | 7\t\t\t\nimport { isUuid, isUuidV1, isUuidV3, isUuidV4, isUuidV5 } from \"@httpx/assert\";\nimport { assertUuid, assertUuidV1, assertUuidV3, assertUuidV4, assertUuidV5 } from \"@httpx/assert\";\nimport { getUuidVersion } from '@httpx/assert';\n// Without version\nisUuid('90123e1c-7512-523e-bb28-76fab9f2f73d'); // üëâ valid uuid v1, 3, 4 or 5\nassertUuid('90123e1c-7512-523e-bb28-76fab9f2f73d');\n// With version\nisUuid('90123e1c-7512-523e-bb28-76fab9f2f73d');\nassertUuid('90123e1c-7512-523e-bb28-76fab9f2f73d');\nassertUuidV5('90123e1c-7512-523e-bb28-76fab9f2f73d')\nisUuidV4('d9428888-122b-11e1-b85c-61cd3cbb3210'); // üëà or isUuidV1(''), isUuidV3(''), isUuidV5('')...;\n// Utils\ngetUuidVersion('90123e1c-7512-523e-bb28-76fab9f2f73d'); // 5","barcode#Barcode":"","isean13#isEan13":"Supported barcodes is currently limited to Ean13\nimport { isEan13 } from \"@httpx/assert\";\nimport { assertEan13 } from \"@httpx/assert\";\nisEan13('1234567890128'); // üëà will check digit too\nassertEan13('1234567890128');","network#Network":"","isnetworkport#isNetWorkPort":"Check whether the value is a valid tcp/udp network port (0-65635)\nimport { isNetworkPort } from \"@httpx/assert\";\nimport { assertNetworkPort } from \"@httpx/assert\";\nimport { type NetworkPort } from \"@httpx/assert\";\nisNetworkPort(443); // üëà weak opaque type is NetworkPort\nassertNetworkPort(443);","http#Http":"","ishttpmethod#isHttpMethod":"Check whether the value is a specific http method (case-insensitive).\nimport { isHttpMethod } from \"@httpx/assert\";\nimport { assertHttpMethod } from \"@httpx/assert\";\nimport { type HttpMethod } from \"@httpx/assert\";\nconst value: unknown = 'GET';\nisHttpMethod('GET', value); // üëà weak opaque type is HttpMethod\nassertHttpMethod('GET', value);","isvalidhttpmethod#isValidHttpMethod":"Check whether the value is a valid http method (case-insensitive).\nimport { isHttpValidMethod } from \"@httpx/assert\";\nimport { assertHttpValidMethod } from \"@httpx/assert\";\nimport { type HttpMethod } from \"@httpx/assert\";\nconst value: unknown = 'GET';\nisHttpValidMethod(value); // üëà weak opaque type is HttpMethod\nassertHttpValidMethod(value);","bundle-size#Bundle size":"Code and bundler have been tuned to target a minimal compressed footprint\nfor the browser.ESM individual imports are tracked by a\nsize-limit configuration.\nScenario\tSize (compressed)\tImport isPlainObject\t~ 56b\tImport isUuid\t~ 175b\tImport isEan13\t~ 117b\tAll typeguards, assertions and helpers\t~ 900b\t\nFor CJS usage (not recommended) track the size on bundlephobia.","compatibility#Compatibility":"Level\tCI\tDescription\tNode\t‚úÖ\tCI for 18.x, 20.x & 22.x.\tBrowsers\t‚úÖ\t> 95% on 12/2023. Mins to Chrome 96+, Firefox 90+, Edge 19+, iOS 12+, Safari 12+, Opera 77+\tEdge\t‚úÖ\tEnsured on CI with @vercel/edge-runtime.\tTypescript\t‚úÖ\tTS 5.0+ / are-the-type-wrong checks on CI.\tES2021\t‚úÖ\tDist files checked with es-check\tNode16\t\tNode 16.x supported, not ensured on CI\t\nFor older browsers: most frontend frameworks can transpile the library (ie: nextjs...)","acknowledgments#Acknowledgments":"Special thanks for inspiration:\nsindresorhus/is\nwebmozarts/assert","contributors#Contributors":"Contributions are warmly appreciated. Have a look to the CONTRIBUTING document.","sponsors#Sponsors":"If my OSS work brightens your day, let's take it to new heights together!\nSponsor, coffee,\nor star ‚Äì any gesture of support fuels my passion to improve. Thanks for being awesome! üôè‚ù§Ô∏è","special-thanks-to#Special thanks to":"JetBrains\nEmbie.be","license#License":"MIT ¬© belgattitude and contributors."}},"/dsn-parser":{"title":"Dsn Parser","data":{"":"DSN & JDBC string parser with query params support in a light and modern package.","features#Features":"üëâ¬† Parse individual fields (ie: driver, user, password, host...)\nüññ¬† Handle query string parameters and converts to boolean and numeric values.\nü¶Ñ¬† Handle special characters like /, :... in the password (some libs won't).\nüöÄ¬† Error with indicative message / reasons (discriminated union or throwable).\nüõ°Ô∏è¬† Don't leak passwords in the error message.\nüôè¬† Assertion and typeguard helpers\nü§ó¬† Ecosystem friendly (ie: zod integration).","install#Install":"yarn add @httpx/dsn-parser\npnpm add @httpx/dsn-parser\nnpm install @httpx/dsn-parser","usage#Usage":"","parsedsnorthrow#parseDsnOrThrow":"Usage with exceptions\nimport { parseDsnOrThrow } from \"@httpx/dsn-parser\";\nconst dsn = \"redis://user:p@/ssword@localhost:6379/0?ssl=true\";\ntry {\n  const parsedDsn = parseDsnOrThrow(dsn);\n  assert.deepEqual(parsedDsn, {\n    driver: \"redis\",\n    pass: \"p@/ssword\",\n    host: \"localhost\",\n    user: \"user\",\n    port: 6379,\n    db: \"0\",\n    params: {\n      ssl: true,\n    },\n  });\n} catch (e) {\n  // example:\n  // e -> Error(\"Can't parse dsn: Invalid port: 12345678 (INVALID_PORT)\")\n}","parsedsn#parseDsn":"Usage with discriminated union.\nimport { parseDsn } from \"@httpx/dsn-parser\";\nconst dsn = \"redis://user:p@/ssword@localhost:6379/0?ssl=true\";\nconst parsed = parseDsn(dsn);\nif (parsed.success) {\n  assert.deepEqual(parsed.value, {\n    driver: \"redis\",\n    pass: \"p@/ssword\",\n    host: \"localhost\",\n    user: \"user\",\n    port: 6379,\n    db: \"0\",\n    params: {\n      ssl: true,\n    },\n  });\n} else {\n  assert.deepEqual(parsed, {\n    success: false,\n    // Reasons might vary\n    reason: \"INVALID_PORT\",\n    message: \"Invalid http port: 12345678\",\n  });\n}","options#Options":"import { parseDsn, type ParseDsnOptions } from \"@httpx/dsn-parser\";\nconst dsn = \"mySql://localhost:6379/db\";\nconst parsed = parseDsn(dsn, {\n  lowercaseDriver: true,\n  // Overrides, allows to force some values (ParseDsnOptions)\n  overrides: {\n    db: \"db3\",\n    port: undefined,\n  },\n});\nassert.deepEqual(parsed.value, {\n  driver: \"mysql\",\n  host: \"localhost\",\n  db: \"db3\",\n});\nParams\tType\tDescription\tlowercaseDriver\tboolean\tDriver name in lowercase, default false\toverrides\tParseDsnOptions\tOverrides allows to force specific values","utilities#Utilities":"","typeguard#Typeguard":"import { isParsableDsn, type ParsableDsn } from \"@httpx/dsn-parser\";\nconst dsn = \"postgresql://localhost:6379/db\";\nif (isParsableDsn(dsn)) {\n  // known to be ParsableDSN\n}","assertion#Assertion":"import { assertParsableDsn, ParsableDsn } from \"@httpx/dsn-parser\";\ntry {\n  assertParsableDsn(\"redis:/\");\n  // Type is narrowed to string (ParsableDsn) if it\n  // didn't throw.\n} catch (e) {\n  assert.equal(e.message, \"Cannot parse DSN (PARSE_ERROR)\");\n}","parsabledsn#ParsableDsn":"ParsableDsn is a weak opaque type.\ndeclare const tag: unique symbol;\nexport type WeakOpaqueContainer<Token> = {\n  readonly [tag]: Token;\n};\nexport type ParsableDsn = string & WeakOpaqueContainer<'ParsableDsn'>;\nIt can be used to enforce that the isParsableDsn or assertParsableDsn have been\nused before usage.\nimport type { ParsableDsn } from \"./dsn-parser.type\";\nimport { assertParsableDsn } from \"./assert-parsable-dsn\";\n// to opt-in, just change the dsn param type to `ParsableDsn` instead of `string`\nconst fnWithWeakOpaqueType = (dsn: ParsableDsn) => {\n    // by explictly requiring a ParsableDsn, we can rely on typescript\n    // to be sure that a validation has occured before (isParsableDsn or assertParsableDsn)\n}\nfnWithWeakOpaqueType('redis://localhost');  // ‚ùå typescript will complain\nconst dsn = 'redis://localhost';\nassertParsableDsn(dsn);\nfnWithWeakOpaqueType(dsn);  // ‚úÖ working cause it was checked before\nPS: WeakOpaque usage is totally optional, a nice to have if applicable","convertjdbctodsn#convertJdbcToDsn":"Utility to convert jdbc dsn.\nUseful for prisma using sqlserver.\nimport { convertJdbcToDsn } from \"@httpx/dsn-parser\";\nconst jdbcDsn =\n  \"sqlserver://localhost:1433;database=my-db;authentication=default;user=sa;password=pass03$;encrypt=true;trustServerCertificate=true\";\nconst dsn = convertJdbcToDsn(jdbc);\n// -> 'sqlserver://localhost:1433?database=my-db&authentication=default&user=sa&password=pass03$&encrypt=true&trustServerCertificate=true'","dsn-parsing#DSN parsing":"","requirements#Requirements":"The minimum requirement for dsn parsing is to have a host and\na driver (/[a-z0-9]+/i) defined. All other options are optional.\nexport type ParsedDsn = {\n  driver: string;\n  host: string;\n  user?: string;\n  pass?: string;\n  port?: number;\n  db?: string;\n  /** Query params */\n  params?: Record<string, number | string | boolean>;\n};","dsn-support#DSN support":"Things like:\nconst validExamples = [\n  \"postgresql://postgres:@localhost:5432/prisma-db\",\n  \"redis://us_er-name:P@ass-_:?/ssw/rd@www.example.com:6379/0?cache=true\",\n  //...\n];\nshould work.","query-parameters#Query parameters":"Simple query parameters are supported (no arrays, no nested). For convenience\nit will cast 'true' and 'false' to booleans,\nparse numeric string to numbers if possible. When a query\nparameter does not contain a value, it will be returned as true.\nconst dsn = \"redis://host?index=1&compress=false&ssl\";\nconst parsed = parseDsn(dsn);\nassert.deepEqual(parsed.value.params, {\n  index: 1,\n  compress: false,\n  ssl: true,\n});","portability#Portability":"parseDsn won't make any assumptions on default values (i.e: default port for mysql...).","validation#Validation":"parseDsn wraps its result in a discriminated union\nto allow the retrieval of validation errors. No try... catchneeded and full typescript support.Reason codes are guaranteed in semantic versions and messages does not\nleak credentials\nconst parsed = parseDsn(\"redis://localhost:65636\");\nassert.deepEqual(parsed, {\n  success: false,\n  reason: \"INVALID_PORT\",\n  message: \"Invalid port: 65636\",\n});\nif (!parsed.success) {\n  // `success: false` narrows the type to\n  // {\n  //   reason: 'PARSE_ERROR'|'INVALID_ARGUMENT'|...\n  //   message: string\n  // }\n  log(parsed.reason);\n}\nReason\tMessage\tComment\t'PARSE_ERROR'\tCannot parse DSN\tRegexp failed\t'INVALID_ARGUMENT'\tDSN must be a string\t\t'EMPTY_DSN'\tDSN cannot be empty\t\t'INVALID_PORT'\tInvalid port: ${port}\t[1-65535]","ecosystem#Ecosystem":"","zod-integration-example#Zod integration example":"The isParsableDsn can be easily plugged into zod custom validation. Example:\nimport { z } from \"zod\";\nimport { isParsableDsn, type ParsableDsn } from \"@httpx/dsn-parser\";\nexport const serverEnvSchema = z.object({\n  PRISMA_DATABASE_URL: z.custom<ParsableDsn>(\n    (dsn) => isParsableDsn(dsn),\n    \"Invalid DSN format.\"\n  ),\n});\nserverEnvSchema.parse(process.env);","faq#Faq":"","why--in-password-matters#Why '/' in password matters":"Some libs (ioredis...) still might fail parsing a password containing '/',\nunfortunately they're pretty convenient, i.e:\nopenssl rand 60 | openssl base64 -A\n# YFUXIG9INIK7dFyE9aXtxLmjmnYL0zv6YluBJJbC6alKIBema/MwEGy3VUpx0oLAvWHUFGFMagAdLxrB"}},"/exception":{"title":"Index","data":{"":"HTTP status errors with default message, instanceof, stack and nested error cause support.\nLightweight, typical usage between 500b and 1300b.\nIncludes convenience typeguards, optional contextual info and a built-in serializer\nto cover cross-environments challenges (RSC, SSR...).","quick-start#Quick start":"yarn add @httpx/exception\npnpm add @httpx/exception\nnpm install @httpx/exception","features#Features":"üëâ¬† Usage by explicit named imports and/or status code.\nüëâ¬† If message not provided, defaults to http error message\nüëâ¬† Supports pre-defined contextual information.\nüëâ¬† Built-in serializer to allow cross-env uses (ssr, rsc, superjson, logs...).\nüëâ¬† Supports nested error through native Error.cause support.\nüëâ¬† Extends native Error class with stacktrace support.\nüëâ¬† No deps. Node, edge and modern browsers compatibility,","usage#Usage":"","by-named-imports#By named imports":"Explicit named imports are prefixed by Http to ease\nIDE experience. Message is optional and default to the default message. Additional\nparameters are supported.\nimport {\n  HttpNotFound,\n  HttpBadRequest,\n} from \"@httpx/exception\";\nconst e = new HttpNotFound();\n// üëâ e.message     -> 'Not found' (default message)\n// üëâ e.statusCode  -> 404\n// üëâ -> e instanceof HttpNotFound (and HttpClientException, HttpException and Error)\nconst e400 = new HttpBadRequest(\"Problems parsing JSON\");\n// üëâ e.message     -> 'Problems parsing JSON'\n// ...","by-status-code#By status code":"The createHttpException function allows to create an exception from an\narbitrary status code.\nimport { createHttpException } from \"@httpx/exception\";\nconst e404 = createHttpException(404); // e404 instanceof HttpClientException\nconst e500 = createHttpException(500); // e500 instanceof HttpServerException\nAdditional parameters can be provided as a second argument.\nimport { createHttpException, HttpNotImplemented } from \"@httpx/exception\";\nthrow createHttpException(404, \"The graal is yet to find !\");\nconst e500 = createHttpException(500, {\n  message: \"Something really wrong happened.\",\n  url: \"https://api.dev/gateway\",\n  cause: new HttpNotImplemented(), // or any Error...\n});","parameters#Parameters":"Http exceptions and createHttpException accept a parameter of type string | HttpExceptionParams. If no parameter\nis provided the default message is used.","error-context#Error context":"It's possible to attach informational context to an exception. This is particularly useful when used with\ncentralized logging / error reporting.\nHttpExceptionParams\tType\tDescription\tmessage\tstring?\tError.message, see about default message.\turl\tstring?\tOrigin url.\tmethod\tHttpMethod?\tOrigin http method.\tcode\tstring?\tCustom error code (not to be confused with statusCode).\terrorId\tstring?\tUnique custom error id.\tcause\tError?\tError.cause, see also about nested errors.\tissues\tValidationIssues[]?\tOnly supported by HttpUnprocessableEntity (422)\t\nExample:\nimport { HttpGatewayTimeout, HttpInternalServerError } from \"@httpx/exception\";\nconst e500 = new HttpInternalServerError({\n  url: \"https://api.dev/gateway\",\n  method: \"GET\",\n  code: \"ERR_UNREACHABLE_SERVICE\",\n  errorId: nanoid(),\n  // üëâ nesting\n  cause: new HttpGatewayTimeout({\n    message: \"This Serverless Function has timed out\",\n    errorId: \"cdg1::h99k2-1664884491087-b41a2832f559\",\n  }),\n});","properties#Properties":"All parameters are exposed as properties.\nHttpExceptionParams\tType\tDescription\tstatusCode\tnumber\tHttp error status code (400-599).\tmessage\tstring\tDefault or provided message.\turl\tstring?\tOrigin url..\tmethod\tHttpMethod?\tOrigin http method.\tcode\tstring?\tCustom error code (not to be confused with statusCode).\terrorId\tstring?\tUnique custom error id.\tstack\tstring?\t@see Error.prototype.stack on MDN.\tcause\tError?\t@see about error cause\tissues\tHttpValidationIssues[]?\tOnly supported by HttpUnprocessableEntity (422)\t\nimport { HttpUnprocessableEntity } from \"@httpx/exception\";\nconst e422 = new HttpUnprocessableEntity({\n  message: \"Request validation failed\",\n  url: \"https://acme.org/api/user/create\",\n  method: \"POST\",\n  issues: [\n    // typed as HttpValidationIssues[]\n    {\n      message: \"Invalid address\",\n      path: [\"addresses\", 0, \"line1\"],\n      code: \"empty_string\",\n    },\n  ],\n});\n// üëâ e422.issues\n// üëâ e422.method === 'POST'\n// ...","nested-errors#Nested errors":"When creating a http exception, it's possible to attach the original error\nto the native Error.cause\nproperty.\nconst e = new HttpBadRequest({\n  // üëâ nesting\n  cause: new TypeError({\n    message: \"Param validation failed\",\n    // üëâ nesting: multiple levels are supported\n    cause: new NoSuchUser(\"User id is invalid\"),\n  }),\n});\nError cause is supported by >93% of browsers as\nof 12/2023. NodeJs supports it since 16.17. Nested cause will simply be discarded if not supported (no runtime error).\nThe error-cause-polyfill can be installed if not provided\nalready by your framework.","static-members#Static members":"All exceptions have a static STATUS readonly property.\nimport { createHttpException, HttpMethodNotAllowed } from \"@httpx/exception\";\nconst { statusCode } = createHttpException(405);\nswitch (statusCode) {\n  case HttpMethodNotAllowed.STATUS:\n    console.log(statusCode); // üëâ 405\n    break;\n}","instanceof-checks#Instanceof checks":"Http exceptions extends the native Error class\nthrough HttpException and either HttpServerException and HttpClientException.\nimport { createHttpException } from \"@httpx/exception\";\nconst e404 = createHttpException(404);\n// üëâ e instanceof Error === true\n// üëâ e instanceof HttpException === true\n// üëâ e instanceof HttpClientException === true\n// üëâ e instanceof HttpNotFound === true\n// üëâ e instanceof HttpServerException === false","class-diagram#Class diagram":"","typeguards#Typeguards":"","instanceof-alternatives#Instanceof alternatives":"While the usage of instanceof is preferred, the isHttpException, isHttpClientException and\nisServerException can be used in place. They will check for instance and will\nalso ensure that the associated statusCode is actually valid.\nimport {\n  isHttpException,\n  isHttpClientException,\n  isHttpServerException,\n} from \"@httpx/exception\";\n// True\nisHttpException(new HttpNotFound());\nisHttpClientException(new HttpNotFound());\nisHttpServerException(new HttpInternalServerError());\n// False\nisHttpClientException(new HttpInternalServerError());\nisHttpServerException(new HttpNotFound());\nisHttpException(new Error());\nisHttpServerException(\n  new (class extends HttpServerException {\n    constructor() {\n      super(400); // 400 isn't a server exception\n    }\n  })()\n);","ishttperrorstatuscode#isHttpErrorStatusCode":"import { isHttpErrorStatusCode } from \"@httpx/exception\";\n// True\nisHttpErrorStatusCode(404);\n// False\nisHttpErrorStatusCode(200);","serializer#Serializer":"Exceptions can be (de-)serialized to json or other formats. Use cases varies from\nssr-frameworks (ie: nextjs getServerSideProps)\n/ loggers (sentry, winston...).Nested error causes are supported but ignored if not supported by\nthe runtime.Additionally, you can pass any native errors (Error, EvalError, RangeError, ReferenceError,\nSyntaxError, TypeError, URIError) as well as a custom one (the later will be transformed to the base type Error).‚ö†Ô∏è Since v3.0.0:For security reasons stack traces\nwon't be serialized anymore by default as they might contain sensitive information in production. To opt-in selectively\nfor stack traces serialization (ie: development or logging)\nconvertToSerializable, createFromSerializable, toJson and fromJson functions\naccepts a SerializerParams.includeStack param as second argument.","json#JSON":"import { fromJson, toJson } from \"@httpx/exception/serializer\";\nconst e = new HttpForbidden();\nconst json = toJson(e); // string\nconst deserialized = fromJson(json);\n// e === deserialized\nTip\nSee also how to integrate with superjson\nExample for stack traces serialization.\nimport { fromJson, toJson } from \"@httpx/exception/serializer\";\n// To include stack traces (not safe in production)\nconst jsonWithStack = toJson(new HttpException(500), {\n  includeStack: process.env.NODE_ENV === 'development',\n});\nconst eWithStrack = fromJson(json, {\n  includeStack: process.env.NODE_ENV === 'development',\n});","serializable#Serializable":"Same as JSON but before json.parse/stringify. Allows to use a different encoder.\nimport {\n  convertToSerializable,\n  createFromSerializable,\n} from \"@httpx/exception/serializer\";\nconst e = new HttpForbidden({\n  cause: new Error(\"Token was revoked\"),\n});\nconst serializableObject = convertToSerializable(e);\nconst deserialized = createFromSerializable(serializableObject);\n// e === deserialized\nExample for stack traces serialization.\nimport {\n  convertToSerializable,\n  createFromSerializable,\n} from \"@httpx/exception/serializer\";\nconst serializableObject = convertToSerializable(e, {\n  includeStack: process.env.NODE_ENV === 'development',\n});\nconst deserialized = createFromSerializable(serializableObject, {\n  includeStack: process.env.NODE_ENV === 'development',\n});","default-messages#Default messages":"Messages are inferred from the Http exception class name. They are\ncompatible with the popular statuses package.\nStatus\tClass\tMessage\t400\tHttpBadRequest\tBad request\t401\tHttpUnauthorized\tUnauthorized\t402\tHttpPaymentRequired\tPayment required\t403\tHttpForbidden\tForbidden\t404\tHttpNotFound\tNot found\t405\tHttpMethodNotAllowed\tMethod not allowed\t406\tHttpNotAcceptable\tNot acceptable\t407\tHttpProxyAuthenticationRequired\t...\t408\tHttpRequestTimeout\t...\t409\tHttpConflict\t...\t410\tHttpGone\t...\t411\tHttpLengthRequired\t...\t412\tHttpPreConditionFailed\t...\t413\tHttpPayloadTooLarge\t...\t414\tHttpUriTooLong\t...\t415\tHttpUnsupportedMediaType\t...\t416\tHttpRangeNotSatisfiable\t...\t417\tHttpExpectationFailed\t...\t418\tHttpImATeapot\t...\t421\tHttpMisdirectedRequest\t...\t422\tHttpUnprocessableEntity\t...\t423\tHttpLocked\t...\t424\tHttpFailedDependency\t...\t425\tHttpTooEarly\t...\t426\tHttpUpgradeRequired\t...\t428\tHttpPreconditionFailed\t...\t429\tHttpTooManyRequests\t...\t431\tHttpRequestHeaderFieldsTooLarge\t...\t451\tHttpUnavailableForLegalReasons\t...\t\nServer http status error code\nStatus\tClass\tMessage\t500\tHttpInternalServerError\tInternal server error\t501\tHttpNotImplemented\t...\t502\tHttpBadGateway\t...\t503\tHttpServiceUnavailable\t...\t504\tHttpGatewayTimeout\t...\t505\tHttpVersionNotSupported\t...\t506\tHttpVariantAlsoNegotiates\t...\t507\tHttpInsufficientStorage\t...\t508\tHttpLoopDetected\t...\t510\tHttpNotExtended\t...\t511\tHttpNetwordAuthenticationRequired\t...","non-official-status-codes#Non-official status codes":"While their usage is not recommended, some status codes might be found in the wild (generally server status codes).\nimport { createHttpException, HttpServerException } from \"@httpx/exception\";\nconst nonOfficialStatusCodes = [\n  [509, \"Might refer to bandwidth limit\"],\n  [525, \"Might refer to SSL Handshake Failed (ie: cloudflare)\"],\n  [526, \"Might refer to Invalid SSL Certificate (ie: cloudflare)\"],\n  [\"...\", \"...\"],\n];\nconst e = createHttpException(509, {\n  message: \"Bandwidth limit exceeded\",\n  // ... others properties\n});\n// e instanceof HttpServerException\n// alternatively\nconst alternate = new HttpServerException({\n  statusCode: 509,\n  message: \"Bandwidth limit exceeded\",\n  // ... others properties\n});","helpers#Helpers":"","iserrorwitherrorstatuscode#isErrorWithErrorStatusCode":"This typeguard is based on a convention and might help to convert a native error to a specific HttpException.\nimport {\n  isErrorWithErrorStatusCode,\n  createHttpException,\n  type isErrorWithErrorStatusCode\n} from \"@httpx/exception\";\ntry {\n  throw new (class extends Error {\n    statusCode = 400; // <- by convention\n  })();\n} catch (e) {\n  // will check if the value is an Error and that there's a statusCode is >=400 && <600\n  if (isErrorWithErrorStatusCode(e)) {\n    throw createHttpException(e.statusCode, e.message);\n  }\n}","isobjectwitherrorstatuscode#isObjectWithErrorStatusCode":"This typeguard is based on a convention and might help to convert an object to a specific HttpException.\nimport {\n  isObjectWithErrorStatusCode,\n  createHttpException,\n  type ObjectWithErrorStatusCode,\n} from \"@httpx/exception\";\nconst noSuchUser = {\n  statusCode: 404,\n} satisfies ObjectWithErrorStatusCode;\nclass NoSuchItem extends DomainError implements ObjectWithErrorStatusCode {\n  statusCode = 404;\n}\nif (isObjectWithErrorStatusCode(noSuchUser)) {\n  throw createHttpException(e.statusCode, \"Nothing\");\n}","about-bundle#About bundle":"","compatibility#Compatibility":"Level\tCI\tDescription\tNode\t‚úÖ\tCI for 18.x, 20.x & 22.x.\tBrowsers\t‚úÖ\t> 93% on 12/2023. Chrome 96+, Firefox 90+, Edge 19+, ios 15+, Safari 15+ and Opera 77+\tEdge\t‚úÖ\tEnsured on CI with @vercel/edge-runtime.\tTypescript\t‚úÖ\tTS 4.7+ / are-the-type-wrong checks on CI.\tES2022\t‚úÖ\tDist files checked with es-check\t\nFor older browsers:\nüëâ Most frontend frameworks can transpile the library (ie: nextjs...)\nüëâ You might want to add the error-cause-polyfill to support\nnested errors (if not present they are simply discarded - no runtime errors).","bundle-size#Bundle size":"Code and bundler have been tuned to target a minimal compressed footprint\nfor the browser. In ESM, typical usage the bundle size will vary between 500b to 1300b compressed\n(including default messages for the 43 status codes).ESM individual imports are tracked by a\nsize-limit configuration.\nScenario\tSize (compressed)\tImport generic exception (HttpClientException)\t~ 390b\tImport 1 client exception\t~ 425b\tImport 2 client exceptions\t~ 447b\tImport 6 client exceptions\t~ 515b\tImport createHttpException (all 43 exceptions)\t~ 1240b\tImport fromJson (incl all + createHttpException)\t~ 1740b\tAll serializer functions + exceptions + typeguards\t~ 1950b\t\nFor CJS usage (not recommended) track the size on bundlephobia.","packaging#Packaging":"This library offers a dual cjs/esm bundle. The (optional) serializer code has been tuned to\navoid issues with dual package hazards.The export fields and the builds are checked on the CI with are-the-types-wrong.\nPS: Plans to remove cjs support might land in a next major version.","typescript#Typescript":"This library targets typescript 5+ with descriptions (see\nthe generated api docs).","upgrade#Upgrade":"Refer to the UPGRADE.md for detailed information.\nVersion\tComment\t3.x\tSerializer functions don't include stack by default\t2.x\tNode 18.x, modern browsers (see how to transpile)"}}}